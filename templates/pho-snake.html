<!DOCTYPE html>
<html>
<head>
    <title>Phonics Snake Game — Fixed & Improved</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        * { box-sizing: border-box; touch-action: none; -webkit-tap-highlight-color: transparent; }
        html,body { height: 100%; }
        body {
            margin: 0;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #1a1a1a;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        header {
            width: 95vw;
            max-width: 400px;
            display:flex;
            justify-content:space-between;
            align-items:center;
            margin-bottom:10px;
            gap:10px;
        }
        #score {
            font-size: 18px;
        }
        #speedDisplay {
            font-size: 14px;
            opacity: 0.85;
        }
        #gameContainer {
            position: relative;
            width: 95vw;
            max-width: 400px;
            aspect-ratio: 1/1;
        }
        canvas {
            width: 100%;
            height: 100%;
            border: 2px solid #4CAF50;
            background-color: #000;
            display:block;
        }
        #controls {
            margin-top: 12px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            width: 95vw;
            max-width: 400px;
        }
        .control-btn {
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px;
            font-size: 20px;
            touch-action: manipulation;
            min-height: 56px;
            user-select: none;
        }
        .control-btn:active { background-color: #45a049; transform: translateY(1px); }
        #gameOver {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.92);
            padding: 18px;
            text-align: center;
            border-radius: 10px;
            width: 80%;
            box-shadow: 0 6px 18px rgba(0,0,0,0.6);
            z-index: 20;
        }
        #gameOver h2 { margin: 0 0 8px 0; }
        #gameFooter { margin-top: 12px; font-size: 13px; opacity: 0.9; text-align:center; }
        @media (orientation: landscape) {
            body { flex-direction: row; justify-content: center; gap: 20px; align-items: center; }
            header { flex-direction: column; gap:6px; align-items:flex-start; }
            #controls { max-width: 160px; margin-top: 0; }
        }
    </style>
</head>
<body>
    <header>
        <div id="score">Score: 0</div>
        <div id="speedDisplay">Speed: Normal</div>
    </header>

    <div id="gameContainer">
        <canvas id="gameCanvas" tabindex="0"></canvas>
        <div id="gameOver" role="dialog" aria-modal="true">
            <h2>Game Over!</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <div style="display:flex; gap:8px; justify-content:center;">
                <button class="control-btn" id="playAgainBtn">Play Again</button>
                <button class="control-btn" id="returnMenuBtn">Restart</button>
            </div>
        </div>
    </div>

    <div id="controls">
        <div></div>
        <button class="control-btn" id="upBtn">↑</button>
        <div></div>
        <button class="control-btn" id="leftBtn">←</button>
        <button class="control-btn" id="pauseBtn">⏸</button>
        <button class="control-btn" id="rightBtn">→</button>
        <div></div>
        <button class="control-btn" id="downBtn">↓</button>
        <div></div>
    </div>

    <div id="gameFooter">Collect vowels (gold letters) to grow. Hitting consonants ends the game.</div>

    <script>
    (function(){
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Gameplay variables
        let gridSize = 20;           // pixel size of each tile (adjusted at resize)
        let tileCount = 20;          // number of tiles per row/column (adjusted at resize)
        let snake = [{x: 10, y: 10}]; // snake segments: head first
        let letters = [];            // letter objects {x,y,letter,isVowel}
        let dx = 1, dy = 0;          // direction vector
        let pendingDirection = null; // queued direction to avoid instant double-turn issues
        let score = 0;
        let isPaused = false;
        let wallCollision = false;   // set to true to enable walls ending the game
        const vowels = ['A','E','I','O','U'];
        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
        let gameLoop = null;
        let tickInterval = 100;      // ms per tick (lower is faster)
        const minTick = 50;          // fastest speed
        const tickDecreasePerStep = 6; // how much to decrease tick as difficulty rises
        const speedStepScore = 50;   // score points required to increase speed step
        let lastSpeedStep = 0;

        const scoreDisplay = document.getElementById('score');
        const speedDisplay = document.getElementById('speedDisplay');
        const gameOverEl = document.getElementById('gameOver');
        const finalScoreEl = document.getElementById('finalScore');

        // Resize and layout functions
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const size = Math.max(200, container.clientWidth); // ensure not too small
            canvas.width = size;
            canvas.height = size;

            // Recalculate grid size: tileCount (how many tiles across)
            // We'll use tileCount derived from desired gridSize; keep gridSize >= 12
            gridSize = Math.max(12, Math.floor(size / 20));
            tileCount = Math.floor(size / gridSize);
            // Keep snake inside bounds: if out of bounds, reposition head reasonably
            snake[0].x = Math.max(0, Math.min(tileCount - 1, snake[0].x));
            snake[0].y = Math.max(0, Math.min(tileCount - 1, snake[0].y));

            // Regenerate letters (to ensure they are valid within new tileCount)
            generateLetters();
            drawGame();
        }

        // Generate a moderate set of letters so the board isn't overcrowded.
        // Ensure at least a few vowels appear so game can continue.
        function generateLetters() {
            letters = [];
            const positions = new Set();
            const totalTiles = tileCount * tileCount;
            const desiredCount = Math.min(14, Math.max(8, Math.floor(totalTiles / 10))); // adapt to size
            const vowelTarget = Math.max(3, Math.floor(desiredCount / 4));

            // helper to pick a free position
            function pickFreePos() {
                let tries = 0;
                while (tries < 500) {
                    const x = Math.floor(Math.random() * tileCount);
                    const y = Math.floor(Math.random() * tileCount);
                    const key = `${x},${y}`;
                    const conflictsWithSnake = snake.some(s => s.x === x && s.y === y);
                    if (!positions.has(key) && !conflictsWithSnake) {
                        positions.add(key);
                        return {x,y};
                    }
                    tries++;
                }
                // fallback: linear scan
                for (let iy=0; iy<tileCount; iy++){
                    for (let ix=0; ix<tileCount; ix++){
                        const key = `${ix},${iy}`;
                        const conflictsWithSnake = snake.some(s => s.x === ix && s.y === iy);
                        if (!positions.has(key) && !conflictsWithSnake) {
                            positions.add(key);
                            return {x:ix,y:iy};
                        }
                    }
                }
                return null;
            }

            // Place vowels first (guarantee some)
            for (let i = 0; i < vowelTarget; i++) {
                const pos = pickFreePos();
                if (!pos) break;
                const letter = vowels[Math.floor(Math.random() * vowels.length)];
                letters.push({x: pos.x, y: pos.y, letter, isVowel: true});
            }

            // Fill remaining with mostly consonants, but occasionally extra vowels
            const consonants = alphabet.filter(l => !vowels.includes(l));
            while (letters.length < desiredCount) {
                const pos = pickFreePos();
                if (!pos) break;
                const shouldBeVowel = Math.random() < 0.12; // small chance for extra vowel
                const letter = shouldBeVowel ? vowels[Math.floor(Math.random() * vowels.length)]
                                              : consonants[Math.floor(Math.random() * consonants.length)];
                letters.push({x: pos.x, y: pos.y, letter, isVowel: vowels.includes(letter)});
            }
        }

        // Draw everything
        function drawGame() {
            // Clear
            ctx.clearRect(0,0,canvas.width,canvas.height);
            ctx.fillStyle = '#000';
            ctx.fillRect(0,0,canvas.width,canvas.height);

            // Draw grid background subtle (optional)
            // Draw snake
            snake.forEach((segment, index) => {
                ctx.fillStyle = index === 0 ? '#4CAF50' : '#45a049';
                const px = segment.x * gridSize;
                const py = segment.y * gridSize;
                // Slight padding so segments look separated
                ctx.fillRect(px + 1, py + 1, gridSize - 2, gridSize - 2);
            });

            // Draw letters
            letters.forEach(letter => {
                const cx = letter.x * gridSize + gridSize / 2;
                const cy = letter.y * gridSize + gridSize / 2;
                if (letter.isVowel) {
                    ctx.fillStyle = '#FFD700';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    // font size scaled to tile
                    ctx.font = `bold ${Math.floor(gridSize * 0.75)}px Arial`;
                    ctx.fillText(letter.letter, cx, cy + 1); // +1 to visually center
                } else {
                    // consonant marker as red circle with black letter inside
                    ctx.fillStyle = '#FF3B3B';
                    ctx.beginPath();
                    ctx.arc(cx, cy, Math.max(4, gridSize / 2.7), 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#000';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.font = `bold ${Math.floor(gridSize * 0.45)}px Arial`;
                    ctx.fillText(letter.letter, cx, cy);
                }
            });
        }

        // Core update tick
        function updateGame() {
            if (isPaused) return;

            // Apply pending direction if any (queued to avoid reversing into yourself)
            if (pendingDirection) {
                const {ndx, ndy} = pendingDirection;
                // prevent reversal
                if (!(ndx === -dx && ndy === -dy)) {
                    dx = ndx; dy = ndy;
                }
                pendingDirection = null;
            }

            const head = {x: snake[0].x + dx, y: snake[0].y + dy};

            // Handle wrapping or walls
            if (wallCollision) {
                if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                    return gameOver();
                }
            } else {
                head.x = (head.x + tileCount) % tileCount;
                head.y = (head.y + tileCount) % tileCount;
            }

            // Self collision
            for (let i = 0; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    return gameOver();
                }
            }

            // Check letter collisions
            let ateVowel = false;
            for (let i = 0; i < letters.length; i++) {
                const letter = letters[i];
                if (head.x === letter.x && head.y === letter.y) {
                    if (letter.isVowel) {
                        ateVowel = true;
                        score += 10;
                        // remove eaten letter
                        letters.splice(i, 1);
                        // spawn replacement vowel (guarantee to avoid collisions)
                        spawnLetter(true);
                        break;
                    } else {
                        // Hitting a consonant ends the game
                        return gameOver();
                    }
                }
            }

            // Move snake: add new head
            snake.unshift(head);

            // If ate vowel, DON'T pop (grow). Otherwise pop tail.
            if (!ateVowel) {
                snake.pop();
            } else {
                // Maybe increase speed by score thresholds
                adjustSpeedIfNeeded();
            }

            // Update score display
            scoreDisplay.textContent = `Score: ${score}`;

            drawGame();
        }

        function spawnLetter(forceVowel=false) {
            // create one new letter (vowel if forced)
            const positions = new Set(letters.map(l => `${l.x},${l.y}`));
            snake.forEach(s => positions.add(`${s.x},${s.y}`));

            let tries = 0;
            while (tries < 500) {
                const x = Math.floor(Math.random() * tileCount);
                const y = Math.floor(Math.random() * tileCount);
                const key = `${x},${y}`;
                if (!positions.has(key)) {
                    const isVowel = forceVowel ? true : (Math.random() < 0.12);
                    const letter = isVowel ? vowels[Math.floor(Math.random() * vowels.length)]
                                           : alphabet.filter(l => !vowels.includes(l))[Math.floor(Math.random() * (26 - vowels.length))];
                    letters.push({x,y,letter,isVowel});
                    return;
                }
                tries++;
            }
            // fallback: do nothing if board too full
        }

        // Game over handling
        function gameOver() {
            clearGameLoop();
            finalScoreEl.textContent = score;
            gameOverEl.style.display = 'block';
            // freeze movement
            dx = 0; dy = 0;
            isPaused = true;
        }

        // Start/restart
        function restartGame() {
            // Reset
            snake = [{x: Math.floor(tileCount/2), y: Math.floor(tileCount/2)}];
            dx = 1; dy = 0;
            pendingDirection = null;
            score = 0;
            tickInterval = 100;
            lastSpeedStep = 0;
            isPaused = false;
            gameOverEl.style.display = 'none';
            scoreDisplay.textContent = `Score: ${score}`;
            updateSpeedLabel();
            generateLetters();
            setGameLoop();
            drawGame();
            // Focus canvas to catch keyboard events
            canvas.focus();
        }

        // Pause toggle
        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                clearGameLoop();
            } else {
                setGameLoop();
            }
            updateSpeedLabel();
        }

        // Manage interval safely
        function setGameLoop() {
            clearGameLoop();
            gameLoop = setInterval(updateGame, tickInterval);
        }
        function clearGameLoop() {
            if (gameLoop) {
                clearInterval(gameLoop);
                gameLoop = null;
            }
        }

        // Adjust speed based on score thresholds
        function adjustSpeedIfNeeded() {
            const step = Math.floor(score / speedStepScore);
            if (step > lastSpeedStep) {
                lastSpeedStep = step;
                // decrease tickInterval but keep above minTick
                tickInterval = Math.max(minTick, tickInterval - tickDecreasePerStep);
                // restart loop with new interval
                if (!isPaused) setGameLoop();
                updateSpeedLabel();
            }
        }

        function updateSpeedLabel() {
            if (isPaused) {
                speedDisplay.textContent = 'Paused';
                return;
            }
            // human friendly
            if (tickInterval >= 110) speedDisplay.textContent = 'Speed: Slow';
            else if (tickInterval >= 85) speedDisplay.textContent = 'Speed: Normal';
            else if (tickInterval >= 65) speedDisplay.textContent = 'Speed: Fast';
            else speedDisplay.textContent = 'Speed: Very Fast';
        }

        // Input handlers (pointer and keyboard)
        function trySetDirection(ndx, ndy) {
            // Don't allow direct reverse into the neck
            if (snake.length > 1) {
                const neck = snake[1];
                if (snake[0].x + ndx === neck.x && snake[0].y + ndy === neck.y) {
                    return; // ignore reversing
                }
            }
            // queue direction (applies at next tick)
            pendingDirection = {ndx, ndy};
        }

        // Buttons: use pointerdown for cross-device (mouse/touch/pen)
        const upBtn = document.getElementById('upBtn');
        const downBtn = document.getElementById('downBtn');
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const playAgainBtn = document.getElementById('playAgainBtn');
        const returnMenuBtn = document.getElementById('returnMenuBtn');

        // Use pointerdown to capture both touch and mouse; prevent default to avoid scrolling on touch
        [['pointerdown', upBtn, (e) => { e.preventDefault(); trySetDirection(0,-1); }],
         ['pointerdown', downBtn, (e) => { e.preventDefault(); trySetDirection(0,1); }],
         ['pointerdown', leftBtn, (e) => { e.preventDefault(); trySetDirection(-1,0); }],
         ['pointerdown', rightBtn, (e) => { e.preventDefault(); trySetDirection(1,0); }],
         ['pointerdown', pauseBtn, (e) => { e.preventDefault(); togglePause(); }],
         ['click', playAgainBtn, (e) => { e.preventDefault(); restartGame(); }],
         ['click', returnMenuBtn, (e) => { e.preventDefault(); restartGame(); }]
        ].forEach(([ev,el,fn]) => {
            el.addEventListener(ev, fn, {passive:false});
        });

        // Keyboard controls
        window.addEventListener('keydown', (e) => {
            // When game over / pause, space toggles
            if (e.key === ' ' || e.key === 'Spacebar') {
                e.preventDefault();
                togglePause();
                return;
            }
            switch(e.key) {
                case 'ArrowUp': e.preventDefault(); trySetDirection(0,-1); break;
                case 'ArrowDown': e.preventDefault(); trySetDirection(0,1); break;
                case 'ArrowLeft': e.preventDefault(); trySetDirection(-1,0); break;
                case 'ArrowRight': e.preventDefault(); trySetDirection(1,0); break;
                case 'r':
                case 'R':
                    restartGame(); break;
            }
        });

        // Prevent accidental text selection on long touch
        document.addEventListener('touchmove', (e) => { if (e.target === canvas) e.preventDefault(); }, {passive:false});

        // Window resize
        window.addEventListener('resize', () => {
            // small debounce
            clearTimeout(window._resizeTimeout);
            window._resizeTimeout = setTimeout(() => {
                resizeCanvas();
            }, 120);
        });

        // initial setup
        resizeCanvas();
        restartGame();

        // Expose a few functions to console for debugging (optional)
        window.phonicsSnake = {
            restart: restartGame,
            pause: togglePause,
            setWalls: (on) => { wallCollision = !!on; },
            getState: () => ({score, snakeLength: snake.length, tickInterval})
        };

    })();
    </script>
</body>
</html>
