### ðŸ§  Core Principles for Coding Prompts  
1. **Atomic Instructions**  
   - Break tasks into tiny, unambiguous steps.  
2. **Context Control**  
   - Explicitly set language, frameworks, and constraints.  
3. **Defensive Prompting**  
   - Anticipate edge cases and errors.  
4. **Structured Output**  
   - Demand specific formats (JSON, YAML, tests, etc.).  

//SUPERTEMP
**Role**: You are a {Senior X Engineer} expert in {Language/Framework}.  
**Task**: Create {specific output} that solves {business goal}.  

**Requirements**:  
1. Language: {Python/JS/Go/etc.}  
2. Libraries: {Only use stdlib/allowed: pandas, React/etc.}  
3. Input: {Define input format/scructure}  
4. Output: {Define exact output format}  
5. Constraints:  
   - Time: O(n)  
   - Space: O(1)  
   - Edge cases: {list critical cases}  
6. Documentation:  
   - Add {docstrings/TS types}  
   - Include {error handling} for {specific failures}  

**Reasoning Steps**:  
1. First, {explain approach}  
2. Then, {handle edge case X}  
3. Finally, {optimize for Y}  

**Example Format**:  
{Show input/output example or code snippet}  

**Deliver**:  
{File structure / function signature}  


//TEMP
You are an expert {language} developer. Your task is to write {a function/script/class} that {detailed description}.

Requirements:
- Language: {Python/JavaScript/Java/etc.}
- Libraries: {Only use standard library / allowed: numpy, pandas, etc.}
- Input: {Describe input parameters, format, and any constraints}
- Output: {Describe expected return value or output behavior}
- Edge Cases: {List critical edge cases to handle}
- Time Complexity: {O(n) required, etc.}
- Space Complexity: {O(1) required, etc.}

Additional Instructions:
{Any special formatting, error handling, or comments needed}

Think step by step:
1. {Ask the model to outline the approach}
2. {Ask to consider edge cases}
3. {Ask to write efficient code}

Example:
{Provide an example input and expected output, or a code snippet stub}

Now, generate the code as described.


//Ex 1
You are a professional JavaScript developer. Write a function `longestCommonPrefix` that takes an array of strings `strs` and returns the longest common prefix string. If there is no common prefix, return an empty string "".

Requirements:
- Use only standard JavaScript (no external libraries).
- Optimize for minimal time complexity.
- Handle edge cases: empty array, array with one string, and when no common prefix exists.

Think step by step:
1. If the array is empty, return "".
2. Take the first string as the initial prefix.
3. Iterate over the rest of the strings and update the prefix by comparing with the current string.
4. If at any point the prefix becomes empty, break early.

Example:
Input: ["flower","flow","flight"]
Output: "fl"

Now, write the JavaScript code.

//Ex2
You are a senior Java architect. Design a class `MinStack` that supports:
- `void push(int val)`: pushes element val onto the stack.
- `void pop()`: removes the element on the top.
- `int top()`: gets the top element.
- `int getMin()`: retrieves the minimum element in the stack.

Constraints:
- All operations must run in O(1) time per call.
- Use two stacks: one for main stack and one for min tracking.

Think step by step:
1. Use two stacks: `stack` and `minStack`.
2. On push: push to `stack`. If `minStack` is empty or val <= current min, push to `minStack`.
3. On pop: pop from `stack`. If the popped value equals the top of `minStack`, pop from `minStack`.
4. `top()` returns top of `stack`.
5. `getMin()` returns top of `minStack`.

Example Usage:
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); // returns -3
minStack.pop();
minStack.top();    // returns 0
minStack.getMin(); // returns -2

Now, write the Java class accordingly.

//Ex3
You are a senior Python developer. Write a function `merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]` that merges two sorted lists into one sorted list without using any built-in sort functions.

Requirements:
- Time complexity: O(n+m) where n and m are the lengths of the two lists.
- Space complexity: O(n+m) for the output list (acceptable).
- Handle empty lists appropriately.

Think step by step:
1. Use two pointers starting at the beginning of both lists.
2. Compare elements at the pointers and append the smaller one to the result.
3. If one list is exhausted, append the rest of the other list.

Example:
Input: list1 = [1,3,5], list2 = [2,4,6]
Output: [1,2,3,4,5,6]

Now, write the code.

//Ex4
**Role**: Senior Data Engineer using Python 3.10+  
**Task**: Create a parallel CSV processor that calculates mean sales per region.  

**Requirements**:  
1. Language: Python (stdlib only)  
2. Input: List of CSV paths (100GB+ total)  
3. Output: JSON {"region": mean_sales}  
4. Constraints:  
   - Use multiprocessing.Pool  
   - Handle corrupt rows gracefully  
   - Memory: O(1) per worker  
5. Documentation:  
   - Type hints for all functions  
   - Logging on errors  

**Reasoning Steps**:  
1. Chunk files into 10MB batches  
2. Worker: Parse, filter NaNs, calculate per-file means  
3. Reduce: Merge regional dictionaries  

**Example Input**:  
['/data/sales_q1.csv', '/data/sales_q2.csv']  

**Deliver**:  
def process_csvs(file_paths: list[str]) -> dict:  
    ...  
    
 //Ex5   
**Role**: Senior Frontend Engineer using React 18 + TypeScript  
**Task**: Create a paginated data table with sortable columns.  

**Requirements**:  
1. Framework: React + react-table v8  
2. Props:  
   - data: T[]  
   - pageSize: number  
3. Features:  
   - Client-side sorting/pagination  
   - Loading skeletons  
   - Mobile-responsive  
4. Documentation:  
   - JSDoc for all props  
   - Error boundaries  

**Reasoning Steps**:  
1. Create useSortableTable hook  
2. Memoize sorted data  
3. Implement pagination slice  

**Example Format**:  
<DataTable  
  data={users}  
  pageSize={10}  
/>  

**Deliver**:  
export default function DataTable<T>({...}: Props<T>) { ... }  


Ex6
**Role**: SRE using Bash on Ubuntu 22.04  
**Task**: Create a server monitoring script  

**Requirements**:  
1. Run every 5min via cron  
2. Check:  
   - Disk usage >90%  
   - Memory usage >80%  
   - Service httpd status  
3. Output:  
   - JSON to /var/log/server_stats.json  
   - Slack alert on failures  
4. Constraints:  
   - Use jq for JSON  
   - Zero dependencies  

**Reasoning Steps**:  
1. Capture metrics with /proc and df  
2. Compare against thresholds  
3. Curl to Slack webhook on failure  

**Deliver**:  
#!/bin/bash  
# Script name: server_monitor.sh  
...  

